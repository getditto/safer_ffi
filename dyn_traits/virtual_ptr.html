<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>&lt;code&gt;VirtualPtr&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; - `safer_ffi` User Guide</title>
    

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="../">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
    <link rel="stylesheet" href="../theme/book.css">
    

    
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction/_.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li></ol></li><li class="chapter-item expanded "><a href="../usage/_.html"><strong aria-hidden="true">2.</strong> Detailed usage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../usage/cargo-toml.html"><strong aria-hidden="true">2.1.</strong> <code>Cargo.toml</code></a></li><li class="chapter-item expanded "><a href="../usage/lib-rs.html"><strong aria-hidden="true">2.2.</strong> <code>src/lib.rs</code> and header generation</a></li><li class="chapter-item expanded "><a href="../usage/custom-types.html"><strong aria-hidden="true">2.3.</strong> Custom types</a></li></ol></li><li class="chapter-item expanded "><a href="../motivation/_.html"><strong aria-hidden="true">3.</strong> Motivation: safer types across FFI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../motivation/traditional-ffi.html"><strong aria-hidden="true">3.1.</strong> The limits of traditional FFI</a></li><li class="chapter-item expanded "><a href="../motivation/repr-c-forall.html"><strong aria-hidden="true">3.2.</strong> Defined layout for Rust's pervasive types</a></li></ol></li><li class="chapter-item expanded "><a href="../simple-examples/_.html"><strong aria-hidden="true">4.</strong> Simple examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../simple-examples/string_concat.html"><strong aria-hidden="true">4.1.</strong> <code>string_concat</code></a></li><li class="chapter-item expanded "><a href="../simple-examples/max.html"><strong aria-hidden="true">4.2.</strong> Maximum member of an array</a></li></ol></li><li class="chapter-item expanded "><a href="../derive-reprc/_.html"><strong aria-hidden="true">5.</strong> <code>ReprC</code> and <code>#[derive_ReprC]</code></a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../derive-reprc/struct.html"><strong aria-hidden="true">5.1.</strong> On a <code>struct</code></a></li><li class="chapter-item expanded "><a href="../derive-reprc/enum.html"><strong aria-hidden="true">5.2.</strong> On an <code>enum</code></a></li></ol></li><li class="chapter-item expanded "><a href="../ffi-export/_.html"><strong aria-hidden="true">6.</strong> <code>#[ffi_export]</code></a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ffi-export/sanity-checks.html"><strong aria-hidden="true">6.1.</strong> Auto-generated checks</a></li><li class="chapter-item expanded "><a href="../ffi-export/attributes.html"><strong aria-hidden="true">6.2.</strong> Attributes</a></li></ol></li><li class="chapter-item expanded "><a href="../callbacks/_.html"><strong aria-hidden="true">7.</strong> Callbacks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../callbacks/fn_pointers.html"><strong aria-hidden="true">7.1.</strong> Function pointers</a></li><li class="chapter-item expanded "><a href="../callbacks/closures.html"><strong aria-hidden="true">7.2.</strong> Closures</a></li></ol></li><li class="chapter-item expanded "><a href="../dyn_traits/_.html"><strong aria-hidden="true">8.</strong> <code>dyn Trait</code>s / Virtual objects</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dyn_traits/virtual_ptr.html" class="active"><strong aria-hidden="true">8.1.</strong> <code>VirtualPtr&lt;dyn Trait&gt;</code></a></li><li class="chapter-item expanded "><a href="../dyn_traits/derive_reprc_dyn.html"><strong aria-hidden="true">8.2.</strong> <code>#[derive_ReprC(dyn, …)]</code></a></li><li class="chapter-item expanded "><a href="../dyn_traits/futures.html"><strong aria-hidden="true">8.3.</strong> Example: FFI-safe <code>Future</code>s and executors</a></li></ol></li><li class="chapter-item expanded "><a href="../example-ditto/_.html"><strong aria-hidden="true">9.</strong> Example: Real-world use case at Ditto</a></li><li class="chapter-item expanded "><a href="../example-hashmap/_.html"><strong aria-hidden="true">10.</strong> Example: our own <code>hashmap</code> in C</a></li><li class="chapter-item expanded affix "><a href="../appendix/c-compilation.html">Appendix: FFI and C compilation</a></li><li class="chapter-item expanded affix "><a href="../appendix/how-does-safer_ffi-work.html">Appendix: how does <code>safer_ffi</code> work</a></li></ol>
            <span id="sponsored">
                Sponsored by<br/>
                <a href="https://www.ditto.live"><img src="../assets/ditto-logo-with-title-small.png" /></a>
            </span>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme"
                                id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    
                </div>

                <h1 class="menu-title">`safer_ffi` User Guide</h1>

                <div class="right-buttons">
                    
                    <a href="https://github.com/getditto/safer_ffi" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    
                    <a href="../rustdoc/safer_ffi" title="Rust docs" aria-label="Rust docs">
                        <i id="rust-docs-button" class="fa fa-cubes"></i>
                    </a>
                    <a href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                </div>
            </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                        placeholder="Search this book ..." aria-controls="searchresults-outer"
                        aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1><a class="header" href="#virtualptrdyn-trait" id="virtualptrdyn-trait"><code>VirtualPtr&lt;dyn Trait&gt;</code></a></h1>
<p><a href="/safer_ffi/rustdoc/safer_ffi/dyn_traits/struct.VirtualPtr.html"><code>VirtualPtr</code></a> is the key <strong>pointer type</strong> enabling all the FFI-safe <code>dyn</code>-support machinery in <code>safer-ffi</code>.</p>
<ul>
<li>
<p>In order to better convey its purpose and semantics, other names considered for this type (besides a <code>VPtr</code> shorthand) have been:</p>
<ul>
<li><code>DynPtr&lt;dyn Trait&gt;</code></li>
<li><code>DynBox&lt;dyn Trait&gt;</code></li>
<li><code>VirtualBox&lt;dyn Trait&gt;</code> / <code>VBox</code> (this one has been <em>very</em> strongly considered)</li>
</ul>
</li>
</ul>
<p>Indeed, this type embodies <strong>owning pointer</strong> semantics, much like <code>Box</code> does.</p>
<p>But it does so with a twist, hence the dedicated special name: <strong>the owning mode is, itself, virtual/<code>dyn</code></strong>!</p>
<ul>
<li>
<p>As will be seen in the remainder of this post, this aspect of <code>VirtualPtr</code> is gonna be the key element to allow <strong>full type unification across even <em>different pointer types</em>!</strong></p>
<p>For instance, consider:</p>
<pre><code class="language-rust ignore">fn together&lt;'r&gt;(
    a: Box&lt;impl 'r + Trait&gt;,
    b: Rc&lt;impl 'r + Trait&gt;,
    c: &amp;'r impl Trait,
) -&gt; [???; 3] // 🤔🤔🤔
{
    [a.into(), b.into(), c.into()]
}
</code></pre>
<p>With <code>VirtualPtr</code>, we can fully type-erase and thus type-unify all these three types into a common one:</p>
<pre><code class="language-rust ignore"><span class="boring">(
</span>) -&gt; [VirtualPtr&lt;dyn 'r + Trait&gt;; 3] // 💡💡💡
</code></pre>
</li>
</ul>
<h3><a class="header" href="#this-allows-a-unified-type-able-to-cover-all-of-boxdyn-trait-arcdyn-trait-mut-dyn-trait-under-one-same-umbrella" id="this-allows-a-unified-type-able-to-cover-all-of-boxdyn-trait-arcdyn-trait-mut-dyn-trait-under-one-same-umbrella">This allows a unified type able to cover all of <code>Box&lt;dyn Trait&gt;</code>, <code>{A,}Rc&lt;dyn Trait&gt;</code>, <code>&amp;[mut] dyn Trait</code> under one same umbrella</a></h3>
<blockquote>
<p><em>One type to unify them all,</em></p>
<p><em>One type to coërce them,</em></p>
<p><em>One type to bring them all</em></p>
<p><em>and in the erasure bind them.</em></p>
</blockquote>
<p><img src="/safer_ffi/assets/one-virtualptr-to-rule-them-all.jpg" alt="One VirtualPtr to rule them all" /></p>
<h2><a class="header" href="#constructing-a-virtualptr-from-rust" id="constructing-a-virtualptr-from-rust">Constructing a <code>VirtualPtr</code> from Rust</a></h2>
<p>That is, whilst <strong>a <code>Box&lt;impl Trait&gt;</code> can<sup class="footnote-reference"><a href="#repr_c_trait">1</a></sup> be &quot;coërced&quot; <code>.into()</code> a <code>VirtualPtr&lt;dyn Trait&gt;</code></strong>, <code>Box</code> will oftentimes not be the sole pointer/indirection with that capability. Indeed, there will often be other similar &quot;coërcions&quot; from a <code>&amp;impl Trait</code>, a <code>&amp;mut impl Trait</code>, a <code>Rc&lt;impl Trait&gt;</code>, or a <code>Arc&lt;impl Trait + Send + Sync&gt;</code>!</p>
<div class="footnote-definition" id="repr_c_trait"><sup class="footnote-definition-label">1</sup>
<p>provided that <code>dyn Trait</code> be a <code>ReprCTrait</code>, <em>i.e.</em>, that the <code>Trait</code> definition have been <code>#[derive_ReprC(dyn)]</code>-annotated.</p>
</div>
<p>Here is the complete list of possible conversion at the moment:</p>
<ol>
<li>
<h4><a class="header" href="#given-t-where-t--t--trait" id="given-t-where-t--t--trait">Given <code>&lt;T&gt; where T : 'T + Trait</code>,</a></h4>
</li>
<li>
<p>With <code>Trait</code> &quot;being <code>ReprC</code>&quot; / FFI-safe (<em>i.e.</em>, <code>dyn Trait : ReprCTrait</code>)</p>
</li>
</ol>
<table><thead><tr><th><strong><code>From&lt;...&gt;</code></strong></th><th><strong><code>.into()</code></strong></th><th><strong>Notes</strong> for <code>Trait</code></th></tr></thead><tbody>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>VirtualPtr&lt;dyn 'T + Trait&gt;</code></td><td>• (requires <code>T : Clone</code> when <code>Clone</code>-annotated)</td></tr>
<tr><td><code>&amp;T</code></td><td><code>VirtualPtr&lt;dyn '_ + Trait&gt;</code></td><td>• cannot have <code>&amp;mut self</code> methods</td></tr>
<tr><td><code>&amp;mut T</code></td><td><code>VirtualPtr&lt;dyn '_ + Trait&gt;</code></td><td>• cannot be <code>Clone</code>-annotated</td></tr>
<tr><td><code>Rc&lt;T&gt;</code></td><td><code>VirtualPtr&lt;dyn 'T + Trait&gt;</code></td><td>• must be <code>Clone</code>-annotated<br>• cannot have <code>&amp;mut self</code> methods</td></tr>
<tr><td><code>Arc&lt;T&gt;</code></td><td><code>VirtualPtr&lt;dyn 'T + Trait + Send + Sync&gt;</code></td><td>• must be <code>Clone</code>-annotated<br>• cannot have <code>&amp;mut self</code> methods<br>• requires <code>T : Send + Sync</code></td></tr>
</tbody></table>
<ul>
<li>Where &quot;<code>Clone</code>-annotated&quot; refers to the <code>#[derive_Repr(dyn, Clone)]</code> case.</li>
</ul>
<h4><a class="header" href="#remarks" id="remarks">Remarks</a></h4>
<ul>
<li>
<p>Whenever <code>T : 'static</code>, we can pick <code>'T = 'static</code>, so that <code>dyn 'T + Trait</code> may be more succintly written as <code>dyn Trait</code>.</p>
</li>
<li>
<p>If the trait has methods with a <code>Pin</code>ned <code>self</code> receiver, then the <code>From&lt;…&gt;</code>-column needs to be <code>Pin</code>-wrapped.</p>
</li>
<li>
<p><strong><code>+ Send</code> and/or <code>+ Sync</code> can always be added</strong> inside a <code>VirtualPtr</code>, in which case <code>T : Send</code> and/or <code>T : Sync</code> (respectively) will be required.</p>
<ul>
<li>The only exception here is <code>Rc</code>, since <code>Rc&lt;dyn Trait + Send + Sync&gt;</code> <em>&amp; co.</em> are oxymorons which have been deemed not to deserve the necessary codegen (if multiple ownership and <code>Send + Sync</code> is required, use <code>Arc</code>, otherwise, use <code>Rc</code>).</li>
</ul>
<p><strong>Tip</strong>: Since <code>+ Send + Sync</code> is so pervasive(ly recommended for one's sanity) when doing FFI, these can be added as super-traits of our <code>Trait</code>, so that they be implied in both <code>T : Trait</code> and <code>dyn Trait</code>, thereby alleviating the syntax without compromising the thread-safety:</p>
<pre><code class="language-rust ignore">#[derive_ReprC(dyn, /* Clone */)]
trait Trait : Send + Sync {
</code></pre>
<ul>
<li>But be aware that, even with such a super trait annotation, <code>dyn Trait</code> and <code>dyn Trait + Send + Sync</code> will remain being distinct types  as far as Rust is concerned! ⚠️</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#its-ffi-layout-constructing-and-using-virtualptr-from-the-ffi" id="its-ffi-layout-constructing-and-using-virtualptr-from-the-ffi">Its FFI-layout: constructing and using <code>VirtualPtr</code> from the FFI</a></h3>
<p>Given some:</p>
<pre><code class="language-rust ignore">#[derive_ReprC(dyn, /* Clone */)]
trait Trait {
    fn get(&amp;self, _: bool) -&gt; i32;
    fn set(&amp;mut self, _: i32);
    fn method3(&amp;… self, _: Arg1, _: Arg2, …) -&gt; Ret;
    …
}
</code></pre>
<ul>
<li>(with <code>Arg1 : ReprC&lt;CLayout = CArg1&gt;</code>, <em>etc.</em>)</li>
</ul>
<p>A <code>VirtualPtr&lt;dyn Trait&gt;</code> will be laid out as the following:</p>
<pre><code class="language-rust ignore">type ErasedPtr = ptr::NonNull&lt;ty::Erased&gt;; /* modulo const/mut */

#[repr(C)]
struct VirtualPtr&lt;dyn Trait&gt; {
    ptr: ErasedPtr,
    // Note: it is *inlined* / *no* pointer indirection!
    vtable: {
        // the `drop` / `free`ing function.
        release_vptr: unsafe extern fn(ErasedPtr),

        /* if `Clone`-annotated:
        retain_vptr: unsafe extern fn(ErasedPtr) -&gt; VirtualPtr&lt;dyn Trait&gt;, */

        /* and the FFI-safe virtual methods of the trait: */
        get: unsafe extern fn(ErasedPtr, _: CLayoutOf&lt;bool&gt;) -&gt; i32,
        set: unsafe extern fn(ErasedPtr, _: i32),
        method3: unsafe extern fn(ErasedPtr, _: CArg1, _: CArg2, …) -&gt; CRet,
        …
    },
}
</code></pre>
<h2><a class="header" href="#a-fully-virtual-owning-mode" id="a-fully-virtual-owning-mode">A fully virtual owning mode</a></h2>
<p>Remember the sentence above?</p>
<blockquote>
<p>But it does so with a twist, hence the dedicated special name: <strong>the owning mode is, itself, virtual/<code>dyn</code></strong>!</p>
</blockquote>
<p>What this means is that <strong><em>all of the destructor</em> is virtual / <code>dyn</code>amically-dispatched</strong>, for instance (and ditto for <code>.clone()</code>ing, when applicable).</p>
<h3><a class="header" href="#non-fully-virtual-examples" id="non-fully-virtual-examples">Non-fully-virtual examples</a></h3>
<p>To better understand this nuance, consider the opposite (types which are not <em>fully</em> virtual / <code>dyn</code>amically dispatched, such as <code>Box&lt;dyn …&gt;</code>): what happens when you drop a <code>Box&lt;dyn Trait&gt;</code> <em>vs.</em> dropping a <code>Rc&lt;dyn Trait&gt;</code>?</p>
<ul>
<li>
<h4><a class="header" href="#when-you-drop-a-boxdyn-trait" id="when-you-drop-a-boxdyn-trait">when you drop a <code>Box&lt;dyn Trait&gt;</code>:</a></h4>
<ol>
<li>It <em>virtually/<code>dyn</code></em>-amically queries the <code>Layout</code> knowledge of that <code>dyn Trait</code> type-erased data;</li>
<li>It <em>virtually/<code>dyn</code></em>-amically drops the <code>dyn Trait</code> pointee <em>in place</em>;</li>
<li>It then calls <code>dealloc</code> (<code>free</code>) of the backing storage using the aforementioned data <code>Layout</code> (as the layout of the whole allocation, since a <code>Box&lt;T&gt;</code> allocates exactly as much memory as needed to hold a <code>T</code>)</li>
</ol>
<p>This last step is thus <em>statically</em> dispatched, thanks to the <em>static</em>/compile-time knowledge of the hard-coded <code>Box</code> type in <code>Box&lt;dyn Trait&gt;</code>!</p>
<details><summary>Pseudo-code</summary>
<pre><code class="language-rust ignore">//! Pseudo-code!
fn drop(self: &amp;mut Box&lt;dyn …&gt;) {
    let layout = self.dyn_layout(); // (self.vtable.layout)(self.ptr)
    unsafe {
        // SAFETY: this is conceptual pseudo-code and may have bugs.
        self.dyn_drop_in_place(); // (self.vtable.drop_in_place)(self.ptr)
        dealloc(&amp;mut *self as *mut _, layout);
    }
}
</code></pre>
</details>
</li>
<li>
<h4><a class="header" href="#when-you-drop-a-rcdyn-trait" id="when-you-drop-a-rcdyn-trait">when you drop a <code>Rc&lt;dyn Trait&gt;</code>:</a></h4>
<ol>
<li>It <em>virtually/<code>dyn</code></em>-amically queries the <code>Layout</code> knowledge of that <code>dyn Trait</code> type-erased data;</li>
<li>It then embiggens the aforementioned layout so as to get the layout of all of the <code>Rc</code>'s actual pointee / actual allocation (that is, <a href="https://github.com/rust-lang/rust/blob/64165aac68af780182ff89a6eb3982e3c262266e/library/alloc/src/rc.rs#L290-L303">the <code>RcBox</code>, <em>i.e.</em>, the data alongside two reference counters</a>), so as to be able to access those counters,</li>
<li>and then decrements the appropriate counters (mostly the strong count);</li>
<li>if it detects that it was the last owner (strong count from 1 to 0):
<ol>
<li>It <em>virtually/<code>dyn</code></em>-amically drops the <code>dyn Trait</code> pointee <em>in place</em>;</li>
<li>It then calls <code>dealloc</code> (<code>free</code>) for that whole <code>RcBox</code>'s backing storage (when there are no outstanding <code>Weak</code>s).</li>
</ol>
</li>
</ol>
<p>The steps <code>2.</code>, <code>3.</code> and <code>4.2</code> are thus <em>statically</em> dispatched, thanks to the <em>static</em>/compile-time knowledge of the hard-coded <code>Rc</code> type in <code>Rc&lt;dyn Trait&gt;</code>!</p>
<details><summary>Pseudo-code</summary>
<pre><code class="language-rust ignore">//! Pseudo-code!
fn drop(self: &amp;mut Rc&lt;dyn …&gt;) {
    let layout = self.dyn_layout(); // (self.vtable.layout)(self.ptr)
    unsafe {
        // SAFETY: this is conceptual pseudo-code and may have bugs.
        let rcbox: &amp;RcBox&lt;dyn …&gt; = adjust_ptr(self.ptr, layout);
        let prev = rcbox.strong_count.get();
        rcbox.strong_count.set(prev - 1);
        if prev == 1 {
            // if last strong owner
            rcbox.data.dyn_drop_in_place(); // (….vtable.drop_in_place)(….ptr)
            if rcbox.weak_count == … {
                // if no outstanding weaks
                dealloc(rcbox as *const _ as *mut _, layout);
            }
        }
    }
}
</code></pre>
</details>
</li>
</ul>
<p>We can actually even go further, and wonder what Rust does:</p>
<ul>
<li>
<h4><a class="header" href="#when-a-mut-dyn-trait-or-a-dyn-trait-goes-out-of-scope" id="when-a-mut-dyn-trait-or-a-dyn-trait-goes-out-of-scope">when a <code>&amp;mut dyn Trait</code> or a <code>&amp;dyn Trait</code> goes out of scope:</a></h4>
<ol>
<li>
<p>Nothing.</p>
<p>(Since it knows that the <code>&amp;[mut] _</code> types have no drop glue whatsoever)</p>
</li>
</ol>
<p>This step (or rather, lack thereof) is another example of <em>statically</em> dispatched logic.</p>
</li>
</ul>
<p>It should thus now be clear that:</p>
<ul>
<li>
<p>whilst type erasure <em>of the pointee</em> does happen whenever your deal with a <code>ConcretePtr&lt;dyn Trait&gt;</code> such as <code>Box&lt;dyn Trait&gt;</code>, <code>&amp;mut dyn Trait</code>, <em>etc.</em></p>
</li>
<li>
<p>on the other hand, the <code>ConcretePtr</code> behind which such erasure happens is not, itself, type-erased! It is still statically-known, and functionality such as <code>Drop</code>, <code>Clone</code>, or even <code>Copy</code> may take advantage of that information (<em>e.g.</em>, <code>&amp;dyn Trait</code> is <code>Copy</code>).</p>
</li>
</ul>
<h3><a class="header" href="#another-example-dyn_clone" id="another-example-dyn_clone">Another example: <code>dyn_clone()</code></a></h3>
<p>Let's now compare, in the context of type-erased <code>dyn Trait</code> pointees, a static operation <em>vs.</em> a virtual / <code>dyn</code>amically dispatched one.</p>
<p>For starters, let's consider the following <code>Trait</code> definition:</p>
<pre><code class="language-rs">trait Trait : 'static {
    //                 &amp;dyn Trait
    fn dyn_clone(self: &amp;Self) -&gt; Box&lt;dyn Trait&gt;;
}

impl&lt;T : 'static + Clone&gt; Trait for T {
    fn dyn_clone(self: &amp;T) -&gt; Box&lt;dyn Trait&gt; {
        Box::new(T::clone(self)) /* as Box&lt;dyn Trait&gt; */
    }
}
</code></pre>
<p>and now, let's think about and compare the behaviors of the two following functions:</p>
<pre><code class="language-rs">fn clone_box(b: &amp;Box&lt;dyn Trait&gt;) -&gt; Box&lt;dyn Trait&gt; {
    b.dyn_clone()
}

fn clone_rc(r: &amp;Rc&lt;dyn Trait&gt;) -&gt; Rc&lt;dyn Trait&gt; {
    r.clone() // Rc::clone(r)
}
</code></pre>
<ul>
<li><code>clone_box</code> is <code>dyn</code>amically calling and delegating to <code>dyn Trait</code>'s <code>dyn_clone</code> virtual method;</li>
<li><code>clone_rc</code> is statically / within-hard-coded code logic performing a (strong) reference-count increment inside the <code>RcBox&lt;dyn Trait&gt;</code> pointee, thereby never interacting with the <code>dyn Trait</code> value itself.</li>
</ul>
<p>(Granted, the former is performing a statically-dispatched <code>Deref</code> coercion beforehand, and the latter may be <code>dyn</code>amically looking up <code>dyn Trait</code>'s <code>Layout</code>, but the main point still stands).</p>
<h3><a class="header" href="#from-partially-dynamic-to-fully-dynamic" id="from-partially-dynamic-to-fully-dynamic">From partially <code>dyn</code>amic to <em>fully</em> <code>dyn</code>amic</a></h3>
<p>From all this, I hope the hybrid static-<code>dyn</code>amic nature of Rust's <code>ConcretePtr&lt;dyn ErasedPointee&gt;</code> (wide) pointers logic is now more apparent and clearer.</p>
<p>From there, we can then wonder what happens if we made it all <em>fully</em> <code>dynamic</code>: <code>VirtualPtr</code> is born!</p>
<h4><a class="header" href="#summary" id="summary">Summary</a></h4>
<ul>
<li>
<p><em>all</em> of the <code>drop</code> glue is to be <code>dyn</code>amically dispatched (through some virtual <code>fn</code> pointer performing a <code>drop_ptr</code> operation):</p>
<pre><code class="language-rust ignore">//! Pseudo-code
impl&lt;T&gt; DynDrop for Box&lt;T&gt; {
    fn dyn_drop_ptr(self)
    {
        drop::&lt;Box&lt;T&gt;&gt;(self);
    }
}

impl&lt;T&gt; DynDrop for Arc&lt;T&gt; {
    fn dyn_drop_ptr(self)
    {
        drop::&lt;Arc&lt;T&gt;&gt;(self);
    }
}

impl&lt;T&gt; DynDrop for &amp;mut T {
    fn dyn_drop_ptr(self)
    {}
}

impl&lt;T&gt; DynDrop for &amp;T {
    fn dyn_drop_ptr(self)
    {}
}
</code></pre>
<p>Notice how this shall therefore imbue with <code>move</code>/ownership semantics originally-<code>Copy</code> pointers such as <code>&amp;T</code>. Indeed, once we go fully virtual, by virtue of being compatible/type-unified with non-<code>Copy</code> pointers such as <code>Box&lt;T&gt;</code> or <code>&amp;mut T</code>, it means we have to conservatively assume any <code>VirtualPtr&lt;…&gt;</code> instance may have to run significant drop glue at most once, which thence makes <code>VirtualPtr</code>s not be <code>Copy</code>, even when they've originated from a <code>&amp;T</code> reference.</p>
</li>
<li>
<p><code>Clone</code>, if any, is also to be fully <code>dyn</code>amically dispatched as well:</p>
<pre><code class="language-rust ignore">//! Pseudo-code
impl&lt;T&gt; DynClone for Box&lt;T&gt;
where
    T : Clone,
{
    fn dyn_clone_ptr(self: &amp;Self)
      -&gt; Self
    {
        Box::new(T::clone(&amp;**self))
    }
}

impl&lt;T&gt; DynClone for Arc&lt;T&gt; {
    fn dyn_clone_ptr(self: &amp;Self)
      -&gt; Self
    {
        Arc::clone(self)
    }
}

/*
 * no `Clone` for `&amp;mut`, obviously:
 * thus, no `From&lt;&amp;mut T&gt;` for `VirtualPtr&lt;dyn DynClone&gt;` either.
 */

impl&lt;T&gt; DynClone for &amp;'_ T {
    fn dyn_clone_ptr(self: &amp;Self)
      -&gt; Self
    {
        // `&amp;T : Copy`
        *self
    }
}
</code></pre>
<p>Regarding the previous point about <code>&amp;T</code>-originated <code>VirtualPtr</code>s not being <code>Copy</code> anymore, we can see we can get the functional API back (<em>i.e.</em>, <code>Clone</code>), if we pinky promise not to mix such <code>VirtualPtr</code>s with non-<code>Clone</code>-originating pointers (such as <code>&amp;mut T</code>)</p>
<ul>
<li><details><summary>Bonus: <code>&mut T</code>-reborrowing</summary>
<p>If you think about <code>&amp;mut T</code>, whilst not <code>Copy</code>, it's still kind of an interesting pointer, since a <code>&amp;'short mut &amp;'long mut T</code> can yield a <code>&amp;'short mut T</code> through reborrowing, thereby removing one layer of indirection, by &quot;squashing&quot; the lifetimes together into their intersection (which here happens to be the shortest one, <code>'short</code>, since <code>'long : 'short</code>).</p>
<p>In explicit API parlance, this would become:</p>
<pre><code class="language-rust ignore">impl&lt;'long&gt; DynReborrowMut for &amp;'long mut T {
    fn dyn_reborrow_mut(
        //    &amp;'short mut VirtualPtr&lt;dyn 'long + …&gt;
        self: &amp;'short mut Self,
    ) -&gt; &amp;'short mut T
    //   VirtualPtr&lt;dyn 'short + …&gt;
    {
        *self /* `&amp;mut **self` to be precise */
    }
}

impl&lt;'long&gt; DynReborrowMut for &amp;'long T { // …
<span class="boring">}
</span></code></pre>
<p>Despite intellectually interesting, this is nonetheless a niche and contrived API which is therefore not exposed through <code>safer-ffi</code>'s <code>VirtualPtr</code> type, for it is deemed that <code>&amp;'short mut VirtualPtr&lt;dyn 'long + …&gt;</code> ought to offer most of the API of a reborrowed <code>VirtualPtr&lt;dyn 'short + …&gt;</code>.</p>
<hr />
</details>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#related-readconcept-dyn-" id="related-readconcept-dyn-">Related read/concept: <code>dyn *</code></a></h3>
<p>In a way, the API/functionality of <code>VirtualPtr</code> is quite similar to the very recent <code>dyn *</code> experimental<sup class="footnote-reference"><a href="#exp">2</a></sup> <a href="https://dev-doc.rust-lang.org/1.68.0/unstable-book/language-features/dyn-star.html">unstable feature</a> of Rust.</p>
<p>As of this writing<sup class="footnote-reference"><a href="#exp">2</a></sup>, there isn't that much proper documentation about it, and one would have to wander through Zulip discussions to know more about it, but for the following post:</p>
<blockquote>
<h3><a class="header" href="#a-hrefhttpstheincredibleholkorgblog20221212dyn-star-codegena-look-at-dyn-code-generation--by-eric-holka" id="a-hrefhttpstheincredibleholkorgblog20221212dyn-star-codegena-look-at-dyn-code-generation--by-eric-holka"><a href="https://theincredibleholk.org/blog/2022/12/12/dyn-star-codegen/"><em>A Look at dyn* Code Generation</em> — by Eric Holk</a></a></h3>
</blockquote>
<div class="footnote-definition" id="exp"><sup class="footnote-definition-label">2</sup>
<p>as of 1.68.0</p>
</div>
<details><summary>Click here to see my own summary of <code>dyn *</code></summary>
<p>The gist of it is that barring <code>repr(C)</code> / <code>extern &quot;C&quot;</code> / FFI-compatibility considerations about which <code>dyn *</code> does not worry, the idea is kind of the same as <code>VirtualPtr</code>, but for one extra quirk. Instead of a simple thin pointer-sized data pointer, a <code>dyn *</code> will rather use the following &quot;erased data&quot; type:</p>
<pre><code class="language-rust ignore">union ErasedData&lt;const N: usize = 1&gt; {
    ptr: *mut ty::Erased,
    inline: [MaybeUninit&lt;usize&gt;; N],
}

struct dyn* Trait&lt;const N: usize = 1&gt; {
    data: ErasedData&lt;N&gt;,
    vtable: …,
}
</code></pre>
<p>Historically, most platforms have featured <code>*mut _</code> and <code>usize</code> having the same layout, so on those platforms and in the case of <code>N = 1</code> (and papering over <code>MaybeUninit</code> / padding bytes), you may still be seeing a <code>*mut ty::Erased</code> <em>directly</em> rather than an <code>ErasedData</code>.</p>
<p>For instance, we could imagine all this applied to our <code>VirtualPtr</code>s: we'd now be able to implement it for non-pointer types, provided they fit within the <code>ErasedData</code> inline storage!</p>
<pre><code class="language-rust ignore">//! Pseudo-code: currently *NOT* in `safer-ffi`

#[derive_ReprC(dyn)]
trait Example : Clone {
    fn dyn_print(&amp;self);
}

impl Example for usize /* which fits inside `*mut Erased` */ {
    /* auto-generated:
    fn dyn_drop(self)
    {
        /* nothing to do to drop a `usize` since it is `Copy` */
    }

    fn dyn_clone(self: &amp;Self)
      -&gt; Self
    {
        *self
    } */

    fn dyn_print(self: &amp;Self)
    {
        dbg!(*self);
    }
}

fn main()
{
    let n: usize = 42;
    // look ma: no indirection!
    let vptr: VirtualPtr&lt;dyn Example&gt; = n.into();
 /* let vptr = VirtualPtr {
        vptr: ErasedData { inline: n },
        vtable: VTable {
            release_vptr: usize::dyn_drop,
            retain_vptr: usize::dyn_clone,
            dyn_print: usize::dyn_print,
        },
    }; */
    vptr.dyn_print(); // correctly prints `42`.
}
</code></pre>
<ul>
<li>Note that this is currently deemed too niche and is <strong>not</strong> featured by <code>safer-ffi</code>.</li>
</ul>
</details>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="../dyn_traits/_.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    
                    <a rel="next" href="../dyn_traits/derive_reprc_dyn.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a rel="prev" href="../dyn_traits/_.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
            <a rel="next" href="../dyn_traits/derive_reprc_dyn.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];

        // make sure we don't activate google analytics if the developer is
        // inspecting the book locally...
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date(); a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-120925501-5', 'auto');
            ga('send', 'pageview');
        }
    </script>
    

    

    

    

    
    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>
