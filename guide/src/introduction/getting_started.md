{{#include ../links.md}}

# Getting started

### Step 1: `Cargo.toml`

To start using `::safer_ffi`, edit your `Cargo.toml` like so:

```toml
[lib]
crate-type = ["staticlib"]  # and/or "cdylib"

[dependencies]
safer-ffi = { version = "...", features = ["proc_macros"] }

[features]
c-headers = ["safer_ffi/headers"]
```

  - See the [dedicated chapter on `Cargo.toml`][cargo-toml] for more info.

### Step 2: `src/lib.rs`

Then, to export a Rust function to FFI, add the [`#[ffi_export]`][ffi_export]
attribute like so:

```rust,noplaypen
use ::safer_ffi::prelude::*;

/// Adds two integers together.
///
/// \remark Wraps on overflow.
#[ffi_export]
fn add (x: i32, y: i32) -> i32
{
    x.wrapping_add(y)
}
```

  - See [the dedicated chapter on `#[ffi_export]`][ffi_export] for more info.

#### Step 3: Build the library into a binary file

Simply run `cargo build` or `cargo build --release` [to compile the library][
c-compilation] to `target/{debug,release}/libcrate_name.ext` (binary file)

#### Step 4: Generate the C header file

To let `safer_ffi` generate the corresponding C headers, add also the following
to your **`src/lib.rs`**:

```rust,noplaypen
#[::safer_ffi::cfg_headers]
#[test]
fn generate_headers () -> ::std::io::Result<()>
{
    ::safer_ffi::headers::builder()
        .to_file("filename.h")?
        .generate()
}
```

and then run the following command:

```bash
cargo test --features c-headers -- generate_headers --nocapture
```

<details><summary><code>filename.h</code></summary>

```C
/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_EXAMPLE__
#define __RUST_EXAMPLE__

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  Adds two integers together.
 *
 *  \remark Wraps on overflow.
 */
int32_t add (
    int32_t x,
    int32_t y);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_EXAMPLE__ */
```

</details>

### Using it from C

<details><Summary>Click to expand</summary>

Here is a basic example to showcase FFI calling into our `add`
function:

```C
// main.rs
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "filename.h"

int main (int argc, char const * const argv[])
{
    printf("42 + 27 = %" PRId32 "\n", add(42, 27));
    return EXIT_SUCCESS;
}
```

compile it with:

```bash
cc main.c -o main -L target/debug -l crate_name
./main  # Run it!
```

</details>

## Custom Types

Custom types are also supported, as long as they:

  - have a defined C layout;

  - have a [`#[derive_ReprC]`][derive_ReprC] attribute.

### Usage with structs

```rust,noplaypen
#[derive_ReprC] // <- `::safer_ffi`'s attribute
#[repr(C)]      // <- defined C layout is mandatory!
struct Point {
    x: i32,
    y: i32,
}
```

  - See [the dedicated chapter on structs](/derive-reprc/struct.md) for more info.

### Usage with enums

```rust,noplaypen
#[derive_ReprC] // <- `::safer_ffi`'s attribute
#[repr(u8)]     // <- explicit integer `repr` is mandatory!
pub enum Direction {
    Up = 1,
    Down = -1,
}
```

  - See [the dedicated chapter on enums](/derive-reprc/enum.md) for more info.
