#![cfg_attr(rustfmt, rustfmt::skip)]
//! C headers generation.
//!
//! This module is only enabled when the `"headers"` feature of `::safer_ffi` is
//! enabled, which is expected to be done through a cargo feature within the
//! (downstream) crate defining the `#[ffi_export]`ed
//! functions.
//!
//! ```toml
//! [dependencies]
//! safer-ffi = { version = "...", features = ["proc_macros"] }
//!
//! [features]
//! generate-headers = ["safer-ffi/headers"]
//! ```
//!
//! Then, to generate the bindings, just define a
//! `#[safer_ffi::cfg_headers]`-gated `#[test]` function,
//! which can then call the [`builder`] to do the work:
//!
//! ```rust
//! use ::std::{io, fs};
//! use ::safer_ffi::prelude::*;
//!
//! /// Concatenate two strings.
//! ///
//! /// The returned value must be freed with `rust_free`
//! #[ffi_export]
//! fn rust_concat (fst: char_p::Ref<'_>, snd: char_p::Ref<'_>)
//!   -> char_p::Box
//! {
//!     let s: String = format!("{}{}\0", fst, snd);
//!     s   .try_into() // Try to convert to a boxed `char *` pointer
//!         .unwrap()   // Only fails if there is an inner nul byte.
//! }
//!
//! /// Frees a pointer obtained by calling `rust_concat`.
//! #[ffi_export]
//! fn rust_free (it: char_p::Box)
//! {
//!     drop(it);
//! }
//!
//! # macro_rules! ignore { ($($t:tt)*) => () } ignore! {
//! #[::safer_ffi::cfg_headers]
//! #[test]
//! # }
//! fn generate_c_header ()
//!   -> io::Result<()>
//! {
//!     ::safer_ffi::headers::builder()
//!         .with_guard("__ASGARD__")
//!         .to_file("filename.h")?
//!         .generate()
//! }
// //! # generate_c_header().unwrap();
//! ```
//!
//! so that
//!
//! ```shell
//! cargo test --features generate-headers -- \
//!     --exact generate_c_header \
//!     --nocapture
//! ```
//!
//! generates a `"filename.h"` file (⚠️ overwriting it if it exists ⚠️) with
//! the following contents:
//!
//! <pre style="color:#000020;background:#f6f8ff;"><span style="color:#3f7f8f; ">/*! \file */</span>
//! <span style="color:#3f7f8f; ">/*******************************************</span>
//! <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
//! <span style="color:#3f7f8f; ">&nbsp;*  File auto-generated by `::safer_ffi`.  *</span>
//! <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
//! <span style="color:#3f7f8f; ">&nbsp;*  Do not manually edit this file.        *</span>
//! <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
//! <span style="color:#3f7f8f; ">&nbsp;*******************************************/</span>
//!
//! <span style="color:#004a43; ">#</span><span style="color:#004a43; ">ifndef</span><span style="color:#004a43; "> __ASGARD__</span>
//! <span style="color:#004a43; ">#</span><span style="color:#004a43; ">define</span><span style="color:#004a43; "> __ASGARD__</span>
//!
//!
//! <span style="color:#3f7f8f; ">/** \brief</span>
//! <span style="color:#3f7f8f; ">&nbsp;*  Concatenate two strings.</span>
//! <span style="color:#3f7f8f; ">&nbsp;* </span>
//! <span style="color:#3f7f8f; ">&nbsp;*  The returned value must be freed with `rust_free_string`</span>
//! <span style="color:#3f7f8f; ">&nbsp;*/</span>
//! <span style="color:#200080; font-weight:bold; ">char</span> <span style="color:#308080; ">*</span> rust_concat <span style="color:#308080; ">(</span>
//!     <span style="color:#200080; font-weight:bold; ">char</span> <span style="color:#200080; font-weight:bold; ">const</span> <span style="color:#308080; ">*</span> fst<span style="color:#308080; ">,</span>
//!     <span style="color:#200080; font-weight:bold; ">char</span> <span style="color:#200080; font-weight:bold; ">const</span> <span style="color:#308080; ">*</span> snd<span style="color:#308080; ">)</span><span style="color:#406080; ">;</span>
//!
//! <span style="color:#3f7f8f; ">/** \brief</span>
//! <span style="color:#3f7f8f; ">&nbsp;*  Frees a pointer obtained by calling `rust_concat`.</span>
//! <span style="color:#3f7f8f; ">&nbsp;*/</span>
//! <span style="color:#200080; font-weight:bold; ">void</span> rust_free_string <span style="color:#308080; ">(</span>
//!     <span style="color:#200080; font-weight:bold; ">char</span> <span style="color:#308080; ">*</span> it<span style="color:#308080; ">)</span><span style="color:#406080; ">;</span>
//!
//!
//! <span style="color:#004a43; ">#</span><span style="color:#004a43; ">endif</span><span style="color:#004a43; "> </span><span style="color:#595979; ">/* __ASGARD__ */</span>
//! </pre>

#![allow(missing_copy_implementations, missing_debug_implementations)]

use ::std::{
    collections::HashSet,
    env,
    fs,
    io,
    path::Path,
};

use_prelude!();
use rust::{String};
use crate::FfiExport;
pub // (in crate)
mod languages;

pub use definer::{Definer, HashSetDefiner};
mod definer;

macro_rules! with_optional_fields {(
    $(
        $(#[$field_meta:meta])*
        $field:ident : $field_ty:ty
    ),* $(,)?
) => (
    #[derive(Default)]
    pub
    struct Builder<'__, W> {
        target: W,
        $(
            $field : Option<$field_ty>,
        )*
    }

    pub
    fn builder<'__> ()
      -> Builder<'__, WhereTo>
    {
        Builder::default()
    }

    use __::WhereTo;
    mod __ {
        #[derive(Default)]
        pub
        struct WhereTo;
    }

    ::paste::item! {
        impl<'__, W> Builder<'__, W> {
            $(
                $(#[$field_meta])*
                pub
                fn [<with_$field>] (self, $field : $field_ty)
                  -> Self
                {
                    let $field = Some($field);
                    Self {
                        $field,
                        .. self
                    }
                }
            )*
        }
    }

    impl<'__> Builder<'__, WhereTo> {
        /// Specify the path to the file to be generated.
        ///
        /// **⚠️ If it already exists, its contents will be overwritten ⚠️**
        ///
        /// There is no default value here, either `.to_file()` or [`.to_writer()`]
        /// need to be called to be able to [`.generate()`] the headers.
        ///
        /// For more fine-grained control over the "output stream" where the
        /// headers will be written to, use [`.to_writer()`].
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// # fn main () -> ::std::io::Result<()> { Ok({
        /// ::safer_ffi::headers::builder()
        ///     .to_file("my_header.h")?
        ///     .generate()?
        /// # })}
        /// ```
        ///
        /// [`.to_writer()`]: `Builder::to_writer`
        /// [`.generate()`]: `Builder::generate`
        pub
        fn to_file (
            self: Self,
            filename: impl AsRef<Path>,
        ) -> io::Result<Builder<'__, fs::File>>
        {
            Ok(self.to_writer(
                fs::OpenOptions::new()
                    .create(true)/*or*/.truncate(true)
                    .write(true)
                    .open(filename.as_ref())?
            ))
        }

        /// Specify the [`Write`][`io::Write`] "stream" where the headers will
        /// be written to.
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// // Display the headers to the standard output
        /// // (may need the `--nocapture` flag when running the tests)
        /// # fn main () -> ::std::io::Result<()> { Ok({
        /// ::safer_ffi::headers::builder()
        ///     .to_writer(::std::io::stdout())
        ///     .generate()?
        /// # })}
        /// ```
        pub
        fn to_writer<W> (
            self: Self,
            out: W,
        ) -> Builder<'__, W>
        where
            W : io::Write
        {
            let Self {
                target: WhereTo, $(
                $field, )*
                ..
            } = self;
            Builder {
                target: out,
                $($field ,)*
            }
        }
    }

    impl<'__, W : io::Write> Builder<'__, W> {
        /// Generate the C header file.
        pub
        fn generate (self)
          -> io::Result<()>
        {
            let Self { mut target, $($field ,)* } = self;
            Builder {
                target: WhereTo, $(
                $field, )*
            }.generate_with_definer(HashSetDefiner {
                out: &mut target,
                defines_set: Default::default(),
            })
        }

        // pub
        // fn as_mut_dyn (self: &'__ mut Self)
        //   -> Builder<'__, &'__ mut dyn io::Write>
        // where
        //     W : '__,
        // {
        //     let Self { ref mut target, $($field ,)* } = *self;
        //     Builder {
        //         target, $(
        //         $field, )*
        //     }
        // }
    }
)}

with_optional_fields! {
    /// Sets up the name of the `ifndef` guard of the header file.
    ///
    /// It defaults to:
    ///
    /// ```rust,ignore
    /// format!("__RUST_{}__", env::var("CARGO_PKG_NAME")?.to_ascii_uppercase())
    /// ```
    guard: &'__ str,

    /// Sets up the banner of the generated C header file.
    ///
    /// It defaults to:
    ///
    /// ```rust,ignore
    /// concat!(
    ///     "/*! \\file */\n",
    ///     "/*******************************************\n",
    ///     " *                                         *\n",
    ///     " *  File auto-generated by `::safer_ffi`.  *\n",
    ///     " *                                         *\n",
    ///     " *  Do not manually edit this file.        *\n",
    ///     " *                                         *\n",
    ///     " *******************************************/\n",
    /// )
    /// ```
    ///
    /// <pre style="color:#000020;background:#f6f8ff;"><span style="color:#3f7f8f; ">/*! \file */</span>
    /// <span style="color:#3f7f8f; ">/*******************************************</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*  File auto-generated by `::safer_ffi`.  *</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*  Do not manually edit this file.        *</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*                                         *</span>
    /// <span style="color:#3f7f8f; ">&nbsp;*******************************************/</span>
    /// </pre>
    banner: &'__ str,

    /// Sets the [`Language`] of the generated headers.
    ///
    /// It defaults to [`Language::C`].
    language: Language,

    /// Sets prefix for generated functions, structs & enums
    naming_convention : NamingConvention,

    /// Whether to yield a stable header or not (order of defined items guaranteed
    /// not to change provided the source code doesn't change either).
    ///
    /// It defaults to `true`.
    stable_header: bool,
}

impl Builder<'_, WhereTo> {
    /// More customizable version of [`.generate()`][`Builder::generate].
    ///
    /// With this call, one can provide a custom implementation of a [`Definer`],
    /// which can be useful for mock tests, mainly.
    pub
    fn generate_with_definer (self, mut definer: impl Definer)
      -> io::Result<()>
    {
        let config = self;
        // Banner
        config.write_banner(&mut definer)?;
        // Prelude
        config.write_prelude(&mut definer)?;
        // User-provided defs!
        config.write_body(&mut definer)?;
        // Epilogue
        config.write_epilogue(&mut definer)?;
        Ok(())
    }

    fn write_banner(&self, definer: &mut dyn Definer) -> io::Result<()> {
        let banner: &'_ str = self.banner.unwrap_or(concat!(
            "/*! \\file */\n",
            "/*******************************************\n",
            " *                                         *\n",
            " *  File auto-generated by `::safer_ffi`.  *\n",
            " *                                         *\n",
            " *  Do not manually edit this file.        *\n",
            " *                                         *\n",
            " *******************************************/\n",
        ));
        writeln!(definer.out(), "{}", banner)
    }

    fn write_prelude(&self, definer: &mut dyn Definer) -> io::Result<()> {
        let lang = self.language.unwrap_or(Language::C);

        let guard = self.guard();

        let package_name = Self::package_name();

        match lang {
            | Language::C => write!(definer.out(),
                include_str!("templates/c/_prelude.h"),
                guard = guard,
            ),

            #[cfg(feature = "csharp-headers")]
            | Language::CSharp => {
                let namespace = Self::camel_cased_package_name();
                write!(definer.out(),
                include_str!("templates/csharp/_prelude.cs"),
                NameSpace = namespace,
                RustLib = package_name,
            )
        },
        }
    }

    /// Heart of safer ffi : write the items in the header
    fn write_body(&self, definer: &mut dyn Definer) -> io::Result<()>{
        let lang = self.language.unwrap_or(Language::C);
        let naming_convention = self.naming_convention.as_ref().unwrap_or(&NamingConvention::Default);

        for ffi_export in self.ffi_export_iterator() {
            ffi_export.generate(definer, lang, naming_convention)?;
        }

        Ok(())
    }

    /// Return an iterator over the items to be exported
    fn ffi_export_iterator(&self) -> Vec<FfiExport> {
        let stable_header = self.stable_header.unwrap_or(true);
        let mut exports  : Vec<FfiExport> = crate::inventory::iter.into_iter()
            .map(|FfiExport{name, gen_def}| FfiExport{name, gen_def:*gen_def})
            .collect();
        if stable_header {
            exports.sort_by(|FfiExport{name: name_a, ..}, FfiExport{name:name_b, ..}|
                name_a.partial_cmp(name_b).unwrap()
            );
        }
        exports
    }

    fn write_epilogue(&self, definer: &mut dyn Definer) -> io::Result<()>{
        let lang = self.language.unwrap_or(Language::C);
        match lang {
            | Language::C => write!(definer.out(),
                include_str!("templates/c/epilogue.h"),
                guard = self.guard(),
            ),

            #[cfg(feature = "csharp-headers")]
            | Language::CSharp => {
                let pkg_name = Self::camel_cased_package_name();
                    write!(definer.out(),
                include_str!("templates/csharp/epilogue.cs"),
                PkgName = pkg_name,
            )
            },
        }
    }

    fn guard(&self) -> String {
        self.guard.map_or_else( ||
            format!("__RUST_{}__",
                    env::var("CARGO_PKG_NAME")
                        .unwrap()
                        .to_ascii_uppercase()
        ), str::to_string)
    }

    /// Return the package name
    fn package_name() -> String {
        ::std::env::var("CARGO_PKG_NAME")
                .expect("Missing `CARGO_PKG_NAME` env var")
    }

    /// Return a Camel Cased version of the package name
    #[cfg(feature = "csharp-headers")]
    fn camel_cased_package_name() -> String {
        let pkg_name = Self::package_name();
        pkg_name.chars()
            .filter_map({
                let mut underscore = true;
                move |c| Some(match c {
                    | _
                        if underscore
                    => {
                        underscore = false;
                        c.to_ascii_uppercase()
                    },

                    | '_'
                    | '-'
                    => {
                        underscore = true;
                        return None; // continue
                    },

                    | _
                    => {
                        c
                    },
                })
            }).collect::<String>()
    }
}


/// Language of the generated headers.
#[derive(
    Debug,
    Copy, Clone,
    PartialEq, Eq,
)]
pub
enum Language {
    /// C, _lingua franca_ of FFI interop.
    C,

    /// C# (experimental).
    #[cfg(feature = "csharp-headers")]
    #[cfg_attr(feature = "nightly",
        doc(cfg(feature = "csharp-headers"))
    )]
    CSharp,
}

pub type FormatFunction = fn(&str) -> String;
/// Allow user to specify
pub enum NamingConvention {
    Default,
    Suffix(String),
    Prefix(String),
    Custom(FormatFunction),
}

impl NamingConvention {
    pub(crate) fn generate_name(&self, name: &str) -> String {
        // Since some closures are using context - such as suffix or prefix-,
        // they can be coerced into functions.
        // Furthermore, two closures even identical do not have the same type.
        // So we need this hack with Box<dyn Trait>
        let format_function : Box<dyn Fn(&str)->String> = match self {
            // Fix me with _t, etc.
            // May depend of langage ?
            NamingConvention::Default => Box::new(|s| s.to_string()),
            NamingConvention::Suffix(suffix) => Box::new(|s| format!("{}_{}", s, suffix.clone())),
            NamingConvention::Prefix(prefix) => Box::new(|s| format!("{}_{}", prefix.clone(), s)),
            NamingConvention::Custom(ff) => Box::new(|s| ff(s)),
        };
        format_function(name)
    }
}

hidden_export! {
    /// Invoke the language-specific typedef code for the given type.
    fn __define_self__<T : ReprC> (
        definer: &'_ mut dyn Definer,
        lang: Language,
        naming_convention: &NamingConvention,
    ) -> ::std::io::Result<()>
    {
        match lang {
            | Language::C => {
                <T::CLayout as CType>::define_self(&crate::headers::languages::C, definer, naming_convention)
            },
            #[cfg(feature = "csharp-headers")]
            | Language::CSharp => {
                <T::CLayout as CType>::define_self(&crate::headers::languages::CSharp, definer, naming_convention)
            },
        }
    }
}

hidden_export! {
    /// Helpers for the generation of FFI-imported function declarations.
    mod __define_fn__ {
        use super::*;
        use ::std::{
            fmt::Write as _,
            io::Result,
        };

        pub
        fn name (
            out: &'_ mut String,
            f_name: &'_ str,
            lang: Language,
        )
        {
            match lang {
                | Language::C => write!(out,
                    "{} (", f_name.trim(),
                ),

                #[cfg(feature = "csharp-headers")]
                | Language::CSharp => write!(out,
                    "{} (", f_name.trim(),
                ),
            }.expect("`write!`-ing to a `String` cannot fail")
        }

        pub
        fn arg<Arg : ReprC> (
            out: &'_ mut String,
            arg_name: &'_ str,
            lang: Language,
        )
        {
            if out.ends_with("(").not() {
                out.push_str(",");
            }
            match lang {
                | Language::C => write!(out,
                    "\n    {}", Arg::CLayout::name_wrapping_var(&crate::headers::languages::C, arg_name),
                ),

                #[cfg(feature = "csharp-headers")]
                | Language::CSharp => write!(out,
                    "\n        {marshaler}{}", Arg::CLayout::name_wrapping_var(&crate::headers::languages::CSharp, arg_name),
                    marshaler =
                        Arg::CLayout::csharp_marshaler()
                            .map(|m| format!("[MarshalAs({})]\n        ", m))
                            .as_deref()
                            .unwrap_or("")
                    ,
                ),
            }.expect("`write!`-ing to a `String` cannot fail")
        }

        pub
        fn ret<Ret : ReprC> (
            definer: &'_ mut dyn Definer,
            lang: Language,
            mut fname_and_args: String,
        ) -> Result<()>
        {
            let out = definer.out();
            match lang {
                | Language::C => {
                    if fname_and_args.ends_with("(") {
                        fname_and_args.push_str("void");
                    }
                    writeln!(out,
                        "{});\n",
                        Ret::CLayout::name_wrapping_var(&crate::headers::languages::C, &fname_and_args),
                    )
                },

                #[cfg(feature = "csharp-headers")]
                | Language::CSharp => {
                    writeln!(out,
                        concat!(
                            "public unsafe partial class Ffi {{\n    ",
                            "{mb_marshaler}",
                            "[DllImport(RustLib, ExactSpelling = true)] public static unsafe extern\n",
                            "    {});\n",
                            "}}\n",
                        ),
                        Ret::CLayout::name_wrapping_var(&crate::headers::languages::CSharp, &fname_and_args),
                        mb_marshaler =
                            Ret::CLayout::csharp_marshaler()
                                .map(|m| format!("[return: MarshalAs({})]\n    ", m))
                                .as_deref()
                                .unwrap_or("")
                        ,
                    )
                },
            }
        }
    }
}
